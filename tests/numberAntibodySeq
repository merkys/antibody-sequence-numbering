#!/usr/bin/perl
use strict;
use warnings;
use Cwd;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin/../modules";
use File::Temp qw/ tempfile /;
use FastaParser qw/ readFasta /;
use POSIX qw(ceil);


sub findBestDomain
{
	my ($seqFile) = @_;
	my ($fh, $domTblout) = tempfile();
	close($fh);
	
	my $hmmScanResult = qx(hmmscan --domT 100 -T 100 --domtblout $domTblout --noali ../hmms/IG_combined.hmm $seqFile);
	
	open(my $tblout_fh, "<", $domTblout)
		or die "Could not open hmmscan domain table out file: $domTblout";
		
	my %sequences;
	while(my $line = <$tblout_fh>)
	{
		next if $line =~ /^#/;
		my @field = split(/\s+/, $line);
		my $seqInfo = {
					domain	=> $field[0],
					tLen 	=> $field[2],
					qLen 	=> $field[5],
					e_value	=> $field[6],	
					score	=> $field[7],	
					bias	=> $field[8],
					acc	=> $field[-2],
					seq	=> '',
					fullName=> ''
				};
		
		my $id = $field[3];
		if(exists $sequences{$id})
		{
			if($sequences{$id} -> {score} < $seqInfo -> {score})
			{
				$sequences{$id} = $seqInfo;
			}
		}
		else
		{
			$sequences{$id} = $seqInfo;
		}
	}
	unlink $domTblout or warn "Could not unlink $domTblout: $!";
	return \%sequences;
}

sub alignToDomain
{
	my ($seqFile, $domain) = @_;
	my $hmmAlignResults = qx(hmmalign --outformat afa --trim ../hmms/$domain.hmm $seqFile);
	my @hmmAlignResults = split("\n", $hmmAlignResults);
	my $header = $hmmAlignResults[0];
	my $sequence = join("", @hmmAlignResults[1 .. $#hmmAlignResults]);
	
	return $header, $sequence;
}

sub checkForInsertions
{
	my ($seqFile, $domain, $id) = @_;
	my $hmmAlignResults = qx(hmmalign --outformat stockholm --trim ../hmms/$domain.hmm $seqFile);
	my @hmmAlignResults = split("\n", $hmmAlignResults);
	my $gc_rf ='';
	my $seq = '';
	for my $line (@hmmAlignResults)
	{
		if($line =~ /#=GC RF/)
		{
			$line =~/\S+\s+\S+\s+(\S+)/;
			$gc_rf = $1;
		}
		if($line =~ /^$id/)
		{
			$line =~/\S+\s+(\S+)/;
			$seq = $1;
		}
	}
	
	return $gc_rf, $seq;
	
}

sub fixAlignment
{
	my ($seq) = @_;
	my @seq = split('',$seq);
	my $cdr1 = fixCdr($seq, 26, 37, 12);
	#print "cdr1: $cdr1\n";
	my $cdr2 = fixCdr($seq, 55, 64, 10);
	#print "cdr2: $cdr2\n";
	my $tillTheEnd_length = length(join("", @seq[104..$#seq]));
	my $cdr3;
	my $insertionCount =0;
	#print $tillTheEnd_length . "\n";
	if($tillTheEnd_length > 24)
	{
		$insertionCount = $tillTheEnd_length - 24;
		#print $insertionCount . "\n";
		$cdr3 = join("",@seq[104..116]);
		#print "cdr3: $cdr3\n";
	}
	else
	{
		$cdr3 = fixCdr($seq, 104, 116, 13);
		#print "cdr3: $cdr3\n";
	}
	
	return join("", @seq[0..25]) 
		. $cdr1 
		. join("", @seq[38..54]) 
		. $cdr2 
		. join("", @seq[65..103]) 
		. $cdr3 
		. join("", @seq[117..$#seq]), $insertionCount;
}


sub fixCdr
{
	my ($seq, $cdr_start,$cdr_end, $cdr_max_length) = @_;
	my @seq = split('',$seq);
	
	my @cdr = @seq[$cdr_start..$cdr_end];
	my $cdr_current_length = 0;
	my @no_gap_seq;
	for my $residue (@cdr)
	{
		#print $residue;
		if($residue ne "-")
		{
			$cdr_current_length++;
			push @no_gap_seq, $residue;
		}
	}
	#print "\n";
	#print "cdr_current_length: " .  $cdr_current_length . "\n";
	if($cdr_current_length == 0)
	{
		return "-" x $cdr_max_length;
	}
	if($cdr_max_length == $cdr_current_length)
	{
		return join("", @no_gap_seq);
	}
	my $left_part = ceil($cdr_current_length/2);
	my $right_part = $cdr_current_length - $left_part;
	my $gaps_part = $cdr_max_length - $right_part - $left_part;
	#print "left_part: " .  $left_part . "\n";
	#print "right_part: " .  $right_part . "\n";
	#print "gaps_part: " .  $gaps_part . "\n";
	my @fixed_cdr;
	for(my $i = 0; $i<$left_part; $i++)
	{
		push @fixed_cdr, $no_gap_seq[$i];
	}
	
	for(my $i = 0; $i<$gaps_part; $i++)
	{
		push @fixed_cdr, "-";
	}
	
	for(my $i = $left_part; $i < $left_part + $right_part; $i++)
	{
		push @fixed_cdr, $no_gap_seq[$i];
	}
	
	return join("", @fixed_cdr);
}

#sub outIMGT
#{
#	my ($header, $sequence, $domain, $gc_rf) = @_;
#	$header =~ s/>//;
#	my $outputText ="# Domain: $domain\n# Sequence: $header\n";
#	my @seq = split('', $sequence);
#	my $index = 0;
#	my @gc_rf = split('', $gc_rf);
#	my $insert_char = 'a';
#	for(my $i =0; $i < (@seq); $i++)
#	{
#		my $current_char = uc($seq[$i]);
#		if($index > 110 and $gc_rf[$i] eq '.')
#		{
#			$outputText .=  "$current_char\t$index $insert_char\t\n";
#			$insert_char = chr(ord($insert_char) + 1);
#		}
#		else
#		{
#			$index++;
#			$outputText .=  "$current_char\t$index\t\n";
#		}
		
#		
#	}
#	return $outputText . "//\n";
#}

sub outIMGT
{
	my ($header, $sequence, $domain, $insertion_count) = @_;
	$header =~ s/>//;
	my $outputText ="# Domain: $domain\n# Sequence: $header\n";
	my @seq = split('', $sequence);
	if ($seq[-1] eq '-')
	{
		pop @seq;
	}
	my $index = 1;
	my $insertion_left;
	my $insertion_right;
	my @numbering = (1..111);
	#print $insertion_count . "\n";
	if($insertion_count != 0)
	{
		$insertion_right = ceil($insertion_count/2);
		$insertion_left = $insertion_count - $insertion_right;
		#print $insertion_right . "\n";
		#print $insertion_left . "\n";
		for(my $i = 0; $i < $insertion_left; $i++)
		{
			push @numbering, 111 . " " . lc(chr(65 + $i));
		}
		for(my $i = 0; $i < $insertion_right; $i++)
		{
			push @numbering, 112 . " " . lc(chr(64 + $insertion_right - $i));
		}
		
	}
	for(my $i = 0; $i < @seq; $i++)
	{
		my $current_num = 112 + $i;
		push @numbering, $current_num;
	}
	
	for(my $i = 0; $i < @seq; $i++)
	{
		$outputText .=  uc($seq[$i]) . "\t$numbering[$i]\t\n";
	}
	return $outputText . "//\n";
}

sub writeFastaToTMP
{
	my ($header, $seq) = @_;
	my ($tmp_fh, $toAlignFile) = tempfile();
	print $tmp_fh ">" . $header . "\n";
	print $tmp_fh $seq;
	close($tmp_fh);
	return $toAlignFile;
}

sub usage
{
	die "usage\n";
}

my %supportedSchemes = ('imgt' => 1);

my ($numberingScheme, $seqFile, $outputFile);

GetOptions(
	"scheme|s=s" =>  \$numberingScheme,
	"output|o=s" => \$outputFile,
	"input|i=s" => \$seqFile,
) or usage();

unless (defined $seqFile)
{
	print "Error: --input or -i is a required parameter\n";
	usage();
}

$numberingScheme ||= 'imgt';

if(!$supportedSchemes{lc($numberingScheme)})
{
	warn "This sheme is not supported: $numberingScheme\n";
	print "Supported schemes:\n";
	die join("\n", keys %supportedSchemes), "\n";
}


my $fastaSequences_ref = readFasta($seqFile);


my $seqInfo_ref = findBestDomain($seqFile);
my $output = '';
for my $seq (@{$fastaSequences_ref})
{
	my $id = $seq->{header};
	if($seq->{header} =~ /^(\S+)\s/)
	{
		$id = $1;
	}
	my $toAlignFile = writeFastaToTMP($seq->{header}, $seq->{seq});
	my ($header, $sequence) = alignToDomain($toAlignFile, $seqInfo_ref -> {$id}->{domain});
	my ($fixedSeq,$insertion_count) = fixAlignment($sequence);
	#print $insertion_count . "\n";
	$output .= outIMGT($seq->{header}, $fixedSeq, $seqInfo_ref -> {$id}->{domain},$insertion_count);
	unlink $toAlignFile or warn "Could not unlink $toAlignFile: $!";
}

my $out_fh = *STDOUT;
if($outputFile)
{
	open($out_fh, '>', $outputFile)
		or die "Could not open file: $outputFile";
}
print $out_fh $output;
close($out_fh) if $outputFile;


