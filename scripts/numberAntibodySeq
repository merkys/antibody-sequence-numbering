#!/usr/bin/perl
use strict;
use warnings;
use Cwd;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin/../modules";
use File::Temp qw/ tempfile /;
use FastaParser qw/ readFasta /;
use POSIX qw(ceil);
use Seq;

sub findBestDomain
{
	my ($id, $seq) = @_;
	my ($fh, $domTblout) = tempfile();
	close($fh);
	my $fastaTmp = writeFastaToTMP($id, $seq);
	my $hmmScanResult = qx(hmmscan --domT 100 -T 100 --domtblout $domTblout --noali hmms/IG_combined.hmm $fastaTmp);
	
	open(my $tblout_fh, "<", $domTblout)
		or die "Could not open hmmscan domain table out file: $domTblout";
	
	local $/ = "\n";
	my %sequences;
	my $bestScore = 0;
	my $bestDomain = {};
	while(my $line = <$tblout_fh>)
	{
		
		next if $line =~ /^#/;
		my @field = split(/\s+/, $line);
		my $seqInfo = {
					domain	=> $field[0],
					tLen 	=> $field[2],
					qLen 	=> $field[5],
					e_value	=> $field[6],	
					score	=> $field[7],	
					bias	=> $field[8],
					acc	=> $field[-2],
					seq	=> '',
					fullName=> ''
				};
		

		if($bestScore < $seqInfo -> {score})
		{
			$bestDomain = $seqInfo;
			$bestScore = $seqInfo -> {score};
		}
	}
	unlink $domTblout or warn "Could not unlink $domTblout: $!";
	unlink $fastaTmp or warn "Could not unlink $fastaTmp: $!";
	return $bestDomain;
}

sub alignToDomain
{
	my ($seqFile, $domain) = @_;
	my $hmmAlignResults = qx(hmmalign --outformat afa --trim hmms/$domain.hmm $seqFile);
	my @hmmAlignResults = split("\n", $hmmAlignResults);
	my $header = $hmmAlignResults[0];
	my $sequence = join("", @hmmAlignResults[1 .. $#hmmAlignResults]);
	
	return $header, $sequence;
}


sub fixAlignment
{
	my ($seq) = @_;
	my @seq = split('',$seq);
	my $cdr1 = fixCdr($seq, 26, 37, 12);
	#print "cdr1: $cdr1\n";
	my $cdr2 = fixCdr($seq, 55, 64, 10);
	#print "cdr2: $cdr2\n";
	my $tillTheEnd_length = length(join("", @seq[104..$#seq]));
	my $cdr3;
	my $insertionCount =0;
	#print $tillTheEnd_length . "\n";
	if($tillTheEnd_length > 24)
	{
		$insertionCount = $tillTheEnd_length - 24;
		#print $insertionCount . "\n";
		$cdr3 = join("",@seq[104..116]);
		#print "cdr3: $cdr3\n";
	}
	else
	{
		$cdr3 = fixCdr($seq, 104, 116, 13);
		#print "cdr3: $cdr3\n";
	}
	
	return join("", @seq[0..25]) 
		. $cdr1 
		. join("", @seq[38..54]) 
		. $cdr2 
		. join("", @seq[65..103]) 
		. $cdr3 
		. join("", @seq[117..$#seq]), $insertionCount;
}


sub fixCdr
{
	my ($seq, $cdr_start,$cdr_end, $cdr_max_length) = @_;
	my @seq = split('',$seq);
	
	my @cdr = @seq[$cdr_start..$cdr_end];
	my $cdr_current_length = 0;
	my @no_gap_seq;
	for my $residue (@cdr)
	{
		#print $residue;
		if($residue ne "-")
		{
			$cdr_current_length++;
			push @no_gap_seq, $residue;
		}
	}
	#print "\n";
	#print "cdr_current_length: " .  $cdr_current_length . "\n";
	if($cdr_current_length == 0)
	{
		return "-" x $cdr_max_length;
	}
	if($cdr_max_length == $cdr_current_length)
	{
		return join("", @no_gap_seq);
	}
	my $left_part = ceil($cdr_current_length/2);
	my $right_part = $cdr_current_length - $left_part;
	my $gaps_part = $cdr_max_length - $right_part - $left_part;
	#print "left_part: " .  $left_part . "\n";
	#print "right_part: " .  $right_part . "\n";
	#print "gaps_part: " .  $gaps_part . "\n";
	my @fixed_cdr;
	for(my $i = 0; $i<$left_part; $i++)
	{
		push @fixed_cdr, $no_gap_seq[$i];
	}
	
	for(my $i = 0; $i<$gaps_part; $i++)
	{
		push @fixed_cdr, "-";
	}
	
	for(my $i = $left_part; $i < $left_part + $right_part; $i++)
	{
		push @fixed_cdr, $no_gap_seq[$i];
	}
	
	return join("", @fixed_cdr);
}


sub outIMGT
{
	my ($header, $sequence, $domain, $insertion_count) = @_;
	$header =~ s/>//;
	my $outputText ="# Domain: $domain\n# Sequence: $header\n";
	my @seq = split('', $sequence);
	if ($seq[-1] eq '-')
	{
		pop @seq;
	}
	my $index = 1;
	my $insertion_left;
	my $insertion_right;
	my @numbering = (1..111);
	#print $insertion_count . "\n";
	if($insertion_count != 0)
	{
		$insertion_right = ceil($insertion_count/2);
		$insertion_left = $insertion_count - $insertion_right;
		#print $insertion_right . "\n";
		#print $insertion_left . "\n";
		for(my $i = 0; $i < $insertion_left; $i++)
		{
			push @numbering, 111 . " " . lc(chr(65 + $i));
		}
		for(my $i = 0; $i < $insertion_right; $i++)
		{
			push @numbering, 112 . " " . lc(chr(64 + $insertion_right - $i));
		}
		
	}
	for(my $i = 0; $i < @seq; $i++)
	{
		my $current_num = 112 + $i;
		push @numbering, $current_num;
	}
	
	for(my $i = 0; $i < @seq; $i++)
	{
		$outputText .=  uc($seq[$i]) . "\t$numbering[$i]\t\n";
	}
	return $outputText . "//\n";
}

sub writeFastaToTMP
{
	my ($header, $seq) = @_;
	my ($tmp_fh, $tmpFile) = tempfile();
	print $tmp_fh ">" . $header . "\n";
	print $tmp_fh $seq;
	close($tmp_fh);
	return $tmpFile;
}

sub usage
{
	die "usage\n";
}

my %supportedSchemes = ('imgt' => 1);

my ($numberingScheme, $seqFile, $outputFile);

GetOptions(
	"scheme|s=s" =>  \$numberingScheme,
	"output|o=s" => \$outputFile,
	"input|i=s" => \$seqFile,
) or usage();

$numberingScheme ||= 'imgt';

if(!$supportedSchemes{lc($numberingScheme)})
{
	warn "This scheme is not supported: $numberingScheme\n";
	print "Supported schemes:\n";
	die join("\n", keys %supportedSchemes), "\n";
}

my $fh = *STDIN;
if($seqFile)
{
	open($fh, '<', $seqFile)
		or die "Could not open file: $outputFile";
}
my @seq_objects;
{
	local $/ = "\n>";  
	while(my $record = <$fh>)
	{
		chomp $record;
		$record =~ s/^>//;
		
		my $seq_ref = readFasta($record);
		my $domain_ref = findBestDomain($seq_ref -> {id}, $seq_ref->{seq});
		my $new_seq_obj = Seq->new($seq_ref, $domain_ref);
		push @seq_objects, $new_seq_obj;
	}

	close($fh) if $seqFile;
}


my $output = '';
for my $obj (@seq_objects)
{
	my $toAlignFile = writeFastaToTMP($obj->{id}, $obj->{seq});
	my ($header, $sequence) = alignToDomain($toAlignFile, $obj->{domain});
	my ($fixedSeq,$insertion_count) = fixAlignment($sequence);
	#print $insertion_count . "\n";
	$output .= outIMGT($obj->{header}, $fixedSeq, $obj->{domain}, $insertion_count);
	unlink $toAlignFile or warn "Could not unlink $toAlignFile: $!";
}

my $out_fh = *STDOUT;
if($outputFile)
{
	open($out_fh, '>', $outputFile)
		or die "Could not open file: $outputFile";
}
print $out_fh $output;
close($out_fh) if $outputFile;

